package com.cooee.phenix.Folder;


import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Matrix;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Handler;
import android.os.Message;
import android.os.SystemClock;
import android.support.v4.widget.AutoScrollHelper;
import android.text.InputFilter;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.Log;
import android.view.ActionMode;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.view.animation.Animation;
import android.view.animation.LinearInterpolator;
import android.view.animation.RotateAnimation;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.FrameLayout;
import android.widget.ScrollView;
import android.widget.TextView;

import com.android.volley.RequestQueue;
import com.android.volley.Response;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.ImageRequest;
import com.android.volley.toolbox.Volley;
import com.cooee.framework.config.defaultConfig.BaseDefaultConfig;
import com.cooee.framework.function.DynamicEntry.DLManager.Constants;
import com.cooee.framework.function.DynamicEntry.DLManager.StatisticsHandle;
import com.cooee.framework.theme.IOnThemeChanged;
import com.cooee.framework.utils.StringUtils;
import com.cooee.phenix.Alarm;
import com.cooee.phenix.BubbleTextView;
import com.cooee.phenix.CellLayout;
import com.cooee.phenix.Cling;
import com.cooee.phenix.DeviceProfile;
import com.cooee.phenix.DragController;
import com.cooee.phenix.DragLayer;
import com.cooee.phenix.DragSource;
import com.cooee.phenix.DragView;
import com.cooee.phenix.DropTarget;
import com.cooee.phenix.DynamicGrid;
import com.cooee.phenix.IOnAlarmListener;
import com.cooee.phenix.IconCache;
import com.cooee.phenix.Launcher;
import com.cooee.phenix.LauncherAnimUtils;
import com.cooee.phenix.LauncherAppState;
import com.cooee.phenix.LauncherModel;
import com.cooee.phenix.LauncherSettings;
import com.cooee.phenix.R;
import com.cooee.phenix.ShortcutAndWidgetContainer;
import com.cooee.phenix.Utilities;
import com.cooee.phenix.FocusManager.FolderKeyEventListener;
import com.cooee.phenix.Folder.kmob.KmobAdverManager;
import com.cooee.phenix.Folder.kmob.NativeData;
import com.cooee.phenix.Functions.Category.OperateHelp;
import com.cooee.phenix.Functions.DynamicEntry.OperateDynamicMain;
import com.cooee.phenix.Functions.DynamicEntry.OperateDynamicModel;
import com.cooee.phenix.config.defaultConfig.LauncherDefaultConfig;
import com.cooee.phenix.data.AppInfo;
import com.cooee.phenix.data.EnhanceItemInfo;
import com.cooee.phenix.data.FolderInfo;
import com.cooee.phenix.data.FolderInfo.FolderListener;
import com.cooee.phenix.data.ItemInfo;
import com.cooee.phenix.data.ShortcutInfo;


/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends FrameLayout implements DragSource , View.OnClickListener , View.OnLongClickListener , DropTarget , FolderListener , TextView.OnEditorActionListener , View.OnFocusChangeListener
//
, IOnThemeChanged//zhujieping add ,换主题不重启
{
	
	private static final String TAG = "Launcher.Folder";
	protected DragController mDragController;
	protected Launcher mLauncher;
	protected FolderInfo mInfo;
	static final int STATE_NONE = -1;
	static final int STATE_SMALL = 0;
	static final int STATE_ANIMATING = 1;
	static final int STATE_OPEN = 2;
	protected int mExpandDuration;
	protected CellLayout mContent;
	protected ScrollView mScrollView;
	private final LayoutInflater mInflater;
	private final IconCache mIconCache;
	private int mState = STATE_NONE;
	private static final int REORDER_ANIMATION_DURATION = 230;
	private static final int REORDER_DELAY = 250;
	//xiatian start	//fix bug：解决“将文件夹内的图标拖出文件夹后，文件夹没有立刻关闭（会延迟一段时间才关闭）”的问题。
	//	private static final int ON_EXIT_CLOSE_DELAY = 800;//xiatian del
	private static final int ON_EXIT_CLOSE_DELAY = 0;//xiatian add
	//xiatian end
	private boolean mRearrangeOnClose = false;
	protected FolderIcon mFolderIcon;
	protected int mMaxCountX;
	protected int mMaxCountY = 999;
	protected int mMaxNumItems;
	private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
	private Drawable mIconDrawable;
	boolean mItemsInvalidated = false;
	private ShortcutInfo mCurrentDragInfo;
	private View mCurrentDragView;
	boolean mSuppressOnAdd = false;
	private int[] mTargetCell = new int[2];
	private int[] mPreviousTargetCell = new int[2];
	private int[] mEmptyCell = new int[2];
	private Alarm mReorderAlarm = new Alarm();
	private Alarm mOnExitAlarm = new Alarm();
	protected int mFolderNameHeight;
	protected Rect mTempRect = new Rect();
	private boolean mDragInProgress = false;
	private boolean mDeleteFolderOnDropCompleted = false;
	private boolean mSuppressFolderDeletion = false;
	private boolean mItemAddedBackToSelfViaIcon = false;
	FolderEditText mFolderName;
	protected float mFolderIconPivotX;
	protected float mFolderIconPivotY;
	private boolean mIsEditingName = false;
	protected InputMethodManager mInputMethodManager;
	private static String sDefaultFolderName;
	private static String sHintText;
	private int DRAG_MODE_NONE = 0;
	private int DRAG_MODE_REORDER = 1;
	private int mDragMode = DRAG_MODE_NONE;
	private boolean mDestroyed;
	private AutoScrollHelper mAutoScrollHelper;
	private Runnable mDeferredAction;
	private boolean mDeferDropAfterUninstall;
	private boolean mUninstallSuccessful;
	//添加智能分类功能 , change by shlt@2015/02/11 ADD START
	private ShortcutInfo operateMoreAppShortcutInfo = null;
	//添加智能分类功能 , change by shlt@2015/02/11 ADD END
	;
	/**文件夹名称长度*/
	private static final int FOLDER_NAME_LENGTH = 30;//cheyingkun add	//解决“文件夹名称最大长度限制无效”的问题。【i_0010067】
	protected View dynamicView = null;
	protected boolean isFolderNameFocusChange = false;//cheyingkun add start	//解决“修改文件夹名称时，按方向键焦点框移动到图标上，软键盘没关闭”的问题【i_0014558】
	//cheyingkun add start	//文件夹推荐应用
	/**打开文件夹时,显示的推荐应用的布局view*/
	protected View mNativeAdverViewLayout = null;
	/**刷新按鈕*/
	protected View mNtiveAdverRefresh = null;
	/**标志位,是否正在获取广告数据*/
	protected boolean isGetDataForNativeAdver = false;
	protected static RequestQueue queue;
	/**获取广告icon图标成功的标志*/
	private final int GET_NATIVE_ADVER_LOGO_BITMAP_SUCCESS = 0;
	/**获取广告icon图标失败的标记*/
	private final int GET_NATIVE_ADVER_LOGO_BITMAP_FAIL = 1;
	/**原生广告获取图标成功的title列表*/
	private ArrayList<String> getNativeAdverLogoBitmapSuccessTitle = new ArrayList<String>();
	/**原生广告获取图标失败的title列表*/
	private ArrayList<String> getNativeAdverLogoBitmapFailTitle = new ArrayList<String>();
	/**原生广告信息列表*/
	private ArrayList<NativeData> createNativeDataByInfo;
	
	public View getNativeAdverViewLayout()
	{
		return mNativeAdverViewLayout;
	}
	
	public void setNtiveAdverRefresh(
			View mNtiveAdverRefresh )
	{
		this.mNtiveAdverRefresh = mNtiveAdverRefresh;
	}
	
	/**接受原生广告图标获取后发送的消息,并处理*/
	private Handler mHandler = new Handler() {
		
		public void handleMessage(
				android.os.Message msg )
		{
			if( isGetDataForNativeAdver )
			{
				String title = msg.obj.toString();
				//处理收到的消息,判断是成功还是失败.分别加入到不同的列表中
				if( msg.what == GET_NATIVE_ADVER_LOGO_BITMAP_SUCCESS )
				{
					if( !getNativeAdverLogoBitmapSuccessTitle.contains( title ) )
					{
						getNativeAdverLogoBitmapSuccessTitle.add( title );
					}
					if( getNativeAdverLogoBitmapFailTitle.contains( title ) )
					{
						getNativeAdverLogoBitmapFailTitle.remove( title );
					}
				}
				else if( msg.what == GET_NATIVE_ADVER_LOGO_BITMAP_FAIL )
				{
					if( !getNativeAdverLogoBitmapFailTitle.contains( title ) )
					{
						getNativeAdverLogoBitmapFailTitle.add( title );
					}
				}
				else
				{
				}
				//根据消息个数进行不同的逻辑处理
				int sizeSuccess = getNativeAdverLogoBitmapSuccessTitle.size();
				int sizeFail = getNativeAdverLogoBitmapFailTitle.size();
				int sizeCount = createNativeDataByInfo.size();
				if( LauncherDefaultConfig.SWITCH_ENABLE_DEBUG )
					Log.d( "operateNativeData" , StringUtils.concat( " createNativeDataByInfo.size():" , createNativeDataByInfo.size() ) );
				if( sizeSuccess == sizeCount )
				{//如果获取图片成功的个数等于总个数,创建或者更新view
					mNativeAdverViewLayout = KmobAdverManager.getKmobAdverManager( getContext() ).getNativerAdverViewForFolder( getContext() , createNativeDataByInfo , Folder.this );
					setGetDataForNativeAdver( false );
					nativeAdverRefreshStopAnimation();
					if( LauncherDefaultConfig.SWITCH_ENABLE_DEBUG )
						Log.i( "operateNativeData" , " 图片全部加载完毕 success  isGetDataForNativeAdver = false " );
					//view获取成功,更新最后一次刷新时间(显示时间?)
					KmobAdverManager.getKmobAdverManager( mLauncher ).updateLastRefreshTimeForOperateNative();//cheyingkun add	//文件夹推荐应用读取服务器配置(开关、wifi更新、更新间隔)
				}
				else if( sizeSuccess + sizeFail == sizeCount )
				{//否则,如果成功+失败等于总个数,则清空数据
					setGetDataForNativeAdver( false );
					nativeAdverRefreshStopAnimation();
					if( LauncherDefaultConfig.SWITCH_ENABLE_DEBUG )
						Log.w( "operateNativeData" , " 图片全部加载完毕 fail  isGetDataForNativeAdver = false " );
				}
			}
		};
	};
	
	public void setGetDataForNativeAdver(
			boolean isGetDataForNativeAdver )
	{
		this.isGetDataForNativeAdver = isGetDataForNativeAdver;
		clearNativeData();
	}
	
	public boolean isGetDataForNativeAdver()
	{
		return isGetDataForNativeAdver;
	}
	
	/**刷新view开始动画方法*/
	public void nativeAdverRefreshStartAnimation()
	{
		if( mNtiveAdverRefresh != null )
		{
			Animation rotateAnimation = new RotateAnimation( 0f , 359f , mNtiveAdverRefresh.getWidth() / 2 , mNtiveAdverRefresh.getHeight() / 2 );
			rotateAnimation.setDuration( 500 );
			rotateAnimation.setRepeatCount( -1 );
			rotateAnimation.setInterpolator( new LinearInterpolator() );
			mNtiveAdverRefresh.startAnimation( rotateAnimation );
		}
	}
	
	/**刷新view停止动画方法*/
	public void nativeAdverRefreshStopAnimation()
	{
		if( mNtiveAdverRefresh != null )
		{
			mNtiveAdverRefresh.clearAnimation();
		}
	}
	
	//cheyingkun add end	//文件夹推荐应用
	/**
	 * Used to inflate the Workspace from XML.
	 *
	 * @param context The application's context.
	 * @param attrs The attribtues set containing the Workspace's customization values.
	 */
	public Folder(
			Context context ,
			AttributeSet attrs )
	{
		super( context , attrs );
		LauncherAppState app = LauncherAppState.getInstance();
		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
		setAlwaysDrawnWithCacheEnabled( false );
		mInflater = LayoutInflater.from( context );
		mIconCache = app.getIconCache();
		Resources res = getResources();
		mMaxCountX = (int)grid.getNumColumns();
		//文件夹优化 , change by shlt@2015/02/03 DEL START
		//mMaxCountY = (int)grid.numRows;
		//文件夹优化 , change by shlt@2015/02/03 DEL END
		mMaxNumItems = mMaxCountX * mMaxCountY;
		mInputMethodManager = (InputMethodManager)getContext().getSystemService( Context.INPUT_METHOD_SERVICE );
		mExpandDuration = LauncherDefaultConfig.getInt( R.integer.config_folderAnimDuration );
		if( sDefaultFolderName == null )
		{
			sDefaultFolderName = LauncherDefaultConfig.getString( R.string.folder_name );
		}
		if( sHintText == null )
		{
			sHintText = LauncherDefaultConfig.getString( R.string.folder_hint_text );
		}
		mLauncher = (Launcher)context;
		// We need this view to be focusable in touch mode so that when text editing of the folder
		// name is complete, we have something to focus on, thus hiding the cursor and giving
		// reliable behvior when clicking the text field (since it will always gain focus on click).
		setFocusableInTouchMode( true );
	}
	
	@Override
	protected void onFinishInflate()
	{
		super.onFinishInflate();
		mScrollView = (ScrollView)findViewById( R.id.scroll_view );
		mContent = (CellLayout)findViewById( R.id.folder_content );
		//xiatian start	//桌面图标显示的样式（详见BaseDefaultConfig.java中的“ITEM_STYLE_XXX”）。
		//文件夹打开状态下，每个图标的宽高。
		//xiatian del start
		//		LauncherAppState app = LauncherAppState.getInstance();
		//		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
		//		mContent.setCellDimensions( grid.getFolderCellWidthPx() , grid.getFolderCellHeightPx() );
		//xiatian del end
		//xiatian add start
		mContent.setCellDimensions( getCellWidth() , getCellHeight() );//【备注】对于文件夹，由于行列数不定（初始化时设置为0行0列），所以没法在CellLayout的onMeasure方法中，再去算每一个格子的宽高。因此要直接设置。
		//xiatian add end
		//xiatian end
		mContent.setGridSize( 0 , 0 );
		mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled( false );
		mContent.setInvertIfRtl( true );
		mFolderName = (FolderEditText)findViewById( R.id.folder_name );
		mFolderName.setFolder( this );
		mFolderName.setOnFocusChangeListener( this );
		// We find out how tall the text view wants to be (it is set to wrap_content), so that
		// we can allocate the appropriate amount of space for it.
		int measureSpec = MeasureSpec.UNSPECIFIED;
		mFolderName.measure( measureSpec , measureSpec );
		mFolderNameHeight = mFolderName.getMeasuredHeight();
		// We disable action mode for now since it messes up the view on phones
		mFolderName.setCustomSelectionActionModeCallback( mActionModeCallback );
		mFolderName.setOnEditorActionListener( this );
		mFolderName.setSelectAllOnFocus( true );
		mFolderName.setInputType( mFolderName.getInputType() | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS );
		//cheyingkun add start	//解决“文件夹名称最大长度限制无效”的问题。【i_0010067】
		//【问题原因】因为上一步对mFolderName.setInputType  导致xml布局中设置的最大长度无效
		//【解决方案】mFolderName.setFilters 重新设置输入长度限制。  FOLDER_NAME_LENGTH 表示限制输入最大不超过的位数（汉字或者字母）
		mFolderName.setFilters( new InputFilter[]{ new InputFilter.LengthFilter( FOLDER_NAME_LENGTH ) } );
		//cheyingkun add end
		mAutoScrollHelper = new FolderAutoScrollHelper( mScrollView );
	}
	
	private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
		
		public boolean onActionItemClicked(
				ActionMode mode ,
				MenuItem item )
		{
			return false;
		}
		
		public boolean onCreateActionMode(
				ActionMode mode ,
				Menu menu )
		{
			return false;
		}
		
		public void onDestroyActionMode(
				ActionMode mode )
		{
		}
		
		public boolean onPrepareActionMode(
				ActionMode mode ,
				Menu menu )
		{
			return false;
		}
	};
	
	public void onClick(
			View v )
	{
		Object tag = v.getTag();
		if( tag instanceof ShortcutInfo )
		{
			mLauncher.onClick( v );
		}
	}
	
	//cheyingkun add start	//文件夹需求(长按显示边框)
	@Override
	protected void onLayout(
			boolean changed ,
			int l ,
			int t ,
			int r ,
			int b )
	{
		if( FolderIcon.folderStyle == FolderIcon.FOLDER_CUSTOM )
		{
			FrameLayout.LayoutParams params = (FrameLayout.LayoutParams)mFolderName.getLayoutParams();
			params.topMargin = mScrollView.getHeight();
		}
		super.onLayout( changed , l , t , r , b );
	}
	
	//cheyingkun add end
	public boolean onLongClick(
			View v )
	{
		// Return if global dragging is not enabled
		if( !mLauncher.isDraggingEnabled() )
			return true;
		Object tag = v.getTag();
		if( tag instanceof ShortcutInfo )
		{
			ShortcutInfo item = (ShortcutInfo)tag;
			if( !v.isInTouchMode() )
			{
				return false;
			}
			mLauncher.dismissFolderCling( null );
			mLauncher.getWorkspace().onDragStartedWithItem( v );
			mLauncher.getWorkspace().beginDragShared( v , this );
			mIconDrawable = ( (TextView)v ).getCompoundDrawables()[1];
			mCurrentDragInfo = item;
			mEmptyCell[0] = item.getCellX();
			mEmptyCell[1] = item.getCellY();
			mCurrentDragView = v;
			mContent.removeView( mCurrentDragView );
			mInfo.remove( mCurrentDragInfo );
			mDragInProgress = true;
			mItemAddedBackToSelfViaIcon = false;
		}
		return true;
	}
	
	public boolean isEditingName()
	{
		return mIsEditingName;
	}
	
	public void startEditingFolderName()
	{
		mFolderName.setHint( "" );
		mIsEditingName = true;
	}
	
	public void dismissEditingName()
	{
		mInputMethodManager.hideSoftInputFromWindow( getWindowToken() , 0 );
		doneEditingFolderName( true );
	}
	
	public void doneEditingFolderName(
			boolean commit )
	{
		mFolderName.setHint( sHintText );
		// Convert to a string here to ensure that no other state associated with the text field
		// gets saved.
		String newTitle = mFolderName.getText().toString();
		mInfo.setTitle( newTitle );
		LauncherModel.updateItemInDatabase( mLauncher , mInfo );
		if( !isFolderNameFocusChange )//cheyingkun add	//解决“修改文件夹名称时，按方向键焦点框移动到图标上，软键盘没关闭”的问题【i_0014558】
		{
			// In order to clear the focus from the text field, we set the focus on ourself. This
			// ensures that every time the field is clicked, focus is gained, giving reliable behavior.
			requestFocus();
		}
		Selection.setSelection( (Spannable)mFolderName.getText() , 0 , 0 );
		mIsEditingName = false;
	}
	
	public boolean onEditorAction(
			TextView v ,
			int actionId ,
			KeyEvent event )
	{
		if( actionId == EditorInfo.IME_ACTION_DONE )
		{
			dismissEditingName();
			return true;
		}
		return false;
	}
	
	public View getEditTextRegion()
	{
		return mFolderName;
	}
	
	public Drawable getDragDrawable()
	{
		return mIconDrawable;
	}
	
	/**
	 * We need to handle touch events to prevent them from falling through to the workspace below.
	 */
	@Override
	public boolean onTouchEvent(
			MotionEvent ev )
	{
		return true;
	}
	
	public void setDragController(
			DragController dragController )
	{
		mDragController = dragController;
	}
	
	void setFolderIcon(
			FolderIcon icon )
	{
		mFolderIcon = icon;
	}
	
	@Override
	public boolean dispatchPopulateAccessibilityEvent(
			AccessibilityEvent event )
	{
		// When the folder gets focus, we don't want to announce the list of items.
		return true;
	}
	
	/**
	 * @return the FolderInfo object associated with this folder
	 */
	public FolderInfo getInfo()
	{
		return mInfo;
	}
	
	private class GridComparator implements Comparator<ShortcutInfo>
	{
		
		int mNumCols;
		
		public GridComparator(
				int numCols )
		{
			mNumCols = numCols;
		}
		
		@Override
		public int compare(
				ShortcutInfo lhs ,
				ShortcutInfo rhs )
		{
			if( !( lhs instanceof ShortcutInfo && rhs instanceof ShortcutInfo ) )
			{
				return 0;
			}
			int lhIndex = lhs.getCellY() * mNumCols + lhs.getCellX();
			int rhIndex = rhs.getCellY() * mNumCols + rhs.getCellX();
			return( lhIndex - rhIndex );
		}
	}
	
	private void placeInReadingOrder(
			ArrayList<ShortcutInfo> items )
	{
		int maxX = 0;
		int count = items.size();
		for( int i = 0 ; i < count ; i++ )
		{
			ShortcutInfo item = items.get( i );
			if( item.getCellX() > maxX )
			{
				maxX = item.getCellX();
			}
		}
		GridComparator gridComparator = new GridComparator( maxX + 1 );
		Collections.sort( items , gridComparator );
		final int countX = mContent.getCountX();
		for( int i = 0 ; i < count ; i++ )
		{
			int x = i % countX;
			int y = i / countX;
			ShortcutInfo item = items.get( i );
			item.setCellX( x );
			item.setCellY( y );
		}
	}
	
	void bind(
			FolderInfo info )
	{
		mInfo = info;
		ArrayList<ShortcutInfo> children = info.getContents();
		ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
		setupContentForNumItems( children.size() );
		placeInReadingOrder( children );
		int count = 0;
		for( int i = 0 ; i < children.size() ; i++ )
		{
			ShortcutInfo child = (ShortcutInfo)children.get( i );
			if( !createAndAddShortcut( child , R.color.folder_items_text_color ) )
			{
				overflow.add( child );
			}
			else
			{
				count++;
			}
		}
		// We rearrange the items in case there are any empty gaps
		setupContentForNumItems( count );
		// If our folder has too many items we prune them from the list. This is an issue 
		// when upgrading from the old Folders implementation which could contain an unlimited
		// number of items.
		for( ShortcutInfo item : overflow )
		{
			mInfo.remove( item );
			LauncherModel.deleteItemFromDatabase( mLauncher , item );
		}
		mItemsInvalidated = true;
		updateTextViewFocus();
		mInfo.addListener( this );
		//xiatian start	//需求：新建的文件夹名称由显示为空白改为显示为“文件夹”。
		//【备注】如果这里设置为""，则打开文件夹后，名称显示sHintText
		//xiatian del start
		//		if( !sDefaultFolderName.contentEquals( mInfo.title ) )
		//		{
		//			//0010396: 【文件夹】英文状态下，智能分类后的文件夹名称仍然是中文 , change by shlt@2015/03/10 UPD START
		//			//mFolderName.setText( mInfo.title );
		//			mFolderName.setText( mInfo.getTitle() );
		//			//0010396: 【文件夹】英文状态下，智能分类后的文件夹名称仍然是中文 , change by shlt@2015/03/10 UPD END
		//		}
		//		else
		//		{
		//			mFolderName.setText( "" );
		//		}
		//xiatian del end
		mFolderName.setText( mInfo.getTitle() );//xiatian add
		//xiatian end
		if( mInfo.getFolderType() == LauncherSettings.Favorites.FOLDER_TYPE_OPERATE_DYNAMIC )
		{
			mFolderName.setEnabled( false );
		}
		updateItemLocationsInDatabase();
	}
	
	/**
	 * Creates a new UserFolder, inflated from R.layout.user_folder.
	 *
	 * @param context The application's context.
	 *
	 * @return A new UserFolder.
	 */
	static Folder fromXml(
			Context context )
	{
		return (Folder)LayoutInflater.from( context ).inflate( R.layout.user_folder , null );
	}
	
	/**
	 * This method is intended to make the UserFolder to be visually identical in size and position
	 * to its associated FolderIcon. This allows for a seamless transition into the expanded state.
	 */
	protected void positionAndSizeAsIcon()
	{
		if( !( getParent() instanceof DragLayer ) )
			return;
		setScaleX( 0.8f );
		setScaleY( 0.8f );
		setAlpha( 0f );
		setState( STATE_SMALL );
	}
	
	public void addMoreAppView()
	{
		//添加智能分类功能 , change by shlt@2015/02/11 ADD START
		if( operateMoreAppShortcutInfo == null )
		{
			operateMoreAppShortcutInfo = OperateHelp.getInstance( mLauncher ).getOperateMoreAppShortcutInfo( this.getInfo() );
			if( operateMoreAppShortcutInfo != null )
			{
				onAddAndNotInsertDB( operateMoreAppShortcutInfo );
			}
		}
	}
	
	protected AnimatorListenerAdapter mOpenAnimatorListener = new AnimatorListenerAdapter() {
		
		@Override
		public void onAnimationStart(
				Animator animation )
		{
			setState( STATE_ANIMATING );
			//cheyingkun add start	//解决“文件夹第一次打开和之后打开模糊效果不统一”的问题。
			if( Folder.this instanceof FolderFullScreen )
			{
				FolderFullScreen mFolderFullScreen = (FolderFullScreen)Folder.this;
				mFolderFullScreen.setBackgroundColor( getResources().getColor( R.color.folder_full_screen_bg_color_open ) );
			}
			//cheyingkun add end
		}
		
		@Override
		public void onAnimationEnd(
				Animator animation )
		{
			setState( STATE_OPEN );
			setLayerType( LAYER_TYPE_NONE , null );
			Cling cling = mLauncher.showFirstRunFoldersCling();
			if( cling != null )
			{
				cling.bringScrimToFront();
				bringToFront();
				cling.bringToFront();
			}
			setFocusOnFirstChild();
			if( mInfo.getOperateIntent() != null )
			{
				String id = mInfo.getOperateIntent().getStringExtra( OperateDynamicMain.OPEARTE_DYNAMIC_ID );
				if( id != null )
					StatisticsHandle.DynamicEntryClick( mInfo.getTitle() , Integer.parseInt( id ) );
			}
			OperateDynamicModel.popSmartDownloadDialog( mMaxCountX , mInfo , Folder.this );
			if( mLauncher != null && mLauncher.getOperateDynamicMain() != null )
			{
				mLauncher.getOperateDynamicMain().hideOperateFolderHot( mInfo );
			}
		}
	};
	protected AnimatorListenerAdapter mCloseAnimatorListener = new AnimatorListenerAdapter() {
		
		@Override
		public void onAnimationEnd(
				Animator animation )
		{
			onCloseComplete();
			setLayerType( LAYER_TYPE_NONE , null );
			setState( STATE_SMALL );
			//添加智能分类功能 , change by shlt@2015/02/11 ADD START
			removeMoreAppView();
			//添加智能分类功能 , change by shlt@2015/02/11 ADD END
			//cheyingkun add start	//解决“文件夹第一次打开和之后打开模糊效果不统一”的问题。
			if( Folder.this instanceof FolderFullScreen )
			{
				FolderFullScreen mFolderFullScreen = (FolderFullScreen)Folder.this;
				mFolderFullScreen.setBackgroundColor( getResources().getColor( R.color.folder_full_screen_bg_color_close ) );
			}
			//cheyingkun add end
			//cheyingkun add start	//文件夹推荐应用
			hideNativeAdverDialog();
			int categoryFolderId = mInfo.getCategoryFolderId();
			if( mNativeAdverViewLayout == null && !isGetDataForNativeAdver// 
					&& categoryFolderId == Integer.MAX_VALUE//判断不是智能分类文件夹//
					//cheyingkun add start	//文件夹推荐应用读取服务器配置(开关、wifi更新、更新间隔)
					&& KmobAdverManager.getKmobAdverManager( mLauncher ).canShowOperateNativeData()//cheyingkun add	//解决“文件夹推荐应用，时间间隔无效”的问题。【i_0013262】
			//cheyingkun add end	//文件夹推荐应用读取服务器配置(开关、wifi更新、更新间隔)
			)
			{//如果view等于空并且没有正在获取广告,则请求数据
				isGetDataForNativeAdver = true;
				queue = Volley.newRequestQueue( Folder.this.getContext() );
				//显示文件夹运营的view
				KmobAdverManager.getKmobAdverManager( mLauncher ).initNativeAdverAdver( Folder.this );
				//显示文件夹运营的view
			}
			//cheyingkun add end	//文件夹推荐应用
		}
		
		@Override
		public void onAnimationStart(
				Animator animation )
		{
			setState( STATE_ANIMATING );
		}
	};
	
	public void animateOpen()
	{
		//添加智能分类功能 , change by shlt@2015/02/11 ADD START
		addMoreAppView();
		//添加智能分类功能 , change by shlt@2015/02/11 ADD END
		positionAndSizeAsIcon();
		if( dynamicView != null )
		{
			removeView( dynamicView );
			dynamicView = null;
		}
		if( !( getParent() instanceof DragLayer ) )
			return;
		centerAboutIcon();
		PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat( "alpha" , 1 );
		PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat( "scaleX" , 1.0f );
		PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat( "scaleY" , 1.0f );
		final ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder( this , alpha , scaleX , scaleY );
		oa.addListener( mOpenAnimatorListener );
		oa.setDuration( mExpandDuration );
		setLayerType( LAYER_TYPE_HARDWARE , null );
		oa.start();
	}
	
	private void setFocusOnFirstChild()
	{
		View firstChild = mContent.getChildAt( 0 , 0 );
		if( firstChild != null )
		{
			firstChild.requestFocus();
		}
	}
	
	public void animateClosed()
	{
		if( !( getParent() instanceof DragLayer ) )
			return;
		PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat( "alpha" , 0 );
		PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat( "scaleX" , 0.9f );
		PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat( "scaleY" , 0.9f );
		final ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder( this , alpha , scaleX , scaleY );
		oa.addListener( mCloseAnimatorListener );
		oa.setDuration( mExpandDuration );
		setLayerType( LAYER_TYPE_HARDWARE , null );
		oa.start();
	}
	
	public boolean acceptDrop(
			DragObject d )
	{
		final ItemInfo item = (ItemInfo)d.dragInfo;
		//xiatian start	//整理代码：整理接口acceptDrop
		//xiatian del start
		//		final int itemType = item.getItemType();
		//		boolean mItemAcceptDrop = ( itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION || itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT
		//		//
		//		//xiatian add start	//需求:桌面默认配置中，支持配置虚图标（虚图标配置的应用没安装时，支持下载；配置的应用安装后，正常打开）。
		//		//该图标是否相应drop事件
		//		|| itemType == LauncherSettings.Favorites.ITEM_TYPE_VIRTUAL
		//		//xiatian add end
		//		//
		//		);
		//xiatian del end
		boolean mItemAcceptDrop = item.acceptDrop();//xiatian add
		//xiatian end
		return( ( mItemAcceptDrop ) && !isFull() );
	}
	
	protected boolean findAndSetEmptyCells(
			ShortcutInfo item )
	{
		int[] emptyCell = new int[2];
		if( mContent.findCellForSpan( emptyCell , item.getSpanX() , item.getSpanY() ) )
		{
			item.setCellX( emptyCell[0] );
			item.setCellY( emptyCell[1] );
			return true;
		}
		else
		{
			return false;
		}
	}
	
	protected boolean createAndAddShortcut(
			ShortcutInfo item ,
			int color )
	{
		final BubbleTextView textView = (BubbleTextView)mInflater.inflate( R.layout.application , this , false );
		//xiatian start	//整理代码：整理冗余代码，直接调用现有接口即可
		//xiatian del start
		//		Bitmap b = item.getIcon( mIconCache );
		//		//xiatian add start	//添加“图标上显示‘未读信息’和‘未接来电’提示”的功能。
		//		UnreadHelper mUnreadHelper = LauncherAppState.getInstance().getUnreadHelper();
		//		if( mUnreadHelper != null )
		//		{
		//			b = mUnreadHelper.getBitmapWithNum( getContext() , item , b );
		//		}
		//		//xiatian add end
		//		textView.setCompoundDrawables( null , Utilities.createIconDrawable( b ) , null , null );
		//		textView.setText( item.getTitle() );
		//		textView.setTag( item );
		//xiatian del end
		textView.applyFromShortcutInfo( item , mIconCache );//xiatian add
		//xiatian end
		textView.setTextColor( getResources().getColor( color ) );
		textView.setShadowsEnabled( false );
		textView.setOnClickListener( this );
		//xiatian add start	//fix bug：解决“智能分类文件夹中的运营出来的所有推荐应用的图标和所有‘更多应用’图标（智能分类文件夹和非智能分类文件夹中）会响应长按事件”的问题。
		//【备注】
		//	智能分类文件夹中的运营出来的所有推荐应用的图标和所有‘更多应用’图标（智能分类文件夹和非智能分类文件夹中），不响应长按事件，所以不需要注册长按监听。
		//【原因】
		//	1、若view注册长按监听，会导致setLongClickable(true)
		//	2、若view是isLongClickable()为true的状态，则会导致该view在super.onTouchEvent的ACTION_DOWN中注册View.java中的CheckLongPressHelper，若不在run之前调用super.cancelLongPress()，依然会上发performLongClick()消息，导致该view相应长按事件。
		if( item.isOperateVirtualItem() == false )
		//xiatian add end
		{
			textView.setOnLongClickListener( this );
		}
		// We need to check here to verify that the given item's location isn't already occupied
		// by another item.
		if( mContent.getChildAt( item.getCellX() , item.getCellY() ) != null || item.getCellX() < 0 || item.getCellY() < 0 || item.getCellX() >= mContent.getCountX() || item.getCellY() >= mContent
				.getCountY() )
		{
			// This shouldn't happen, log it. 
			if( LauncherDefaultConfig.SWITCH_ENABLE_DEBUG )
				Log.e( TAG , "Folder order not properly persisted during bind" );
			if( !findAndSetEmptyCells( item ) )
			{
				return false;
			}
		}
		CellLayout.LayoutParams lp = new CellLayout.LayoutParams( item.getCellX() , item.getCellY() , item.getSpanX() , item.getSpanY() );
		boolean insert = false;
		if( LauncherDefaultConfig.SWITCH_ENABLE_RESPONSE_ONKEYLISTENER )//cheyingkun add	//桌面是否支持按键机，true支持、false不支持，默认true【c_0004522】
		{
			textView.setOnKeyListener( new FolderKeyEventListener() );
		}
		//xiatian add start	//fix bug：解决“智能分类文件夹中的运营出来的所有推荐应用的图标和所有‘更多应用’图标（智能分类文件夹和非智能分类文件夹中）会响应长按事件”的问题。
		//【备注】
		//	智能分类文件夹中的运营出来的所有推荐应用的图标和所有‘更多应用’图标（智能分类文件夹和非智能分类文件夹中），不响应长按事件。
		//【原因】
		//	若view是isLongClickable()为true的状态，则会导致该view在super.onTouchEvent的ACTION_DOWN中注册View.java中的CheckLongPressHelper，若不在run之前调用super.cancelLongPress()，依然会上发performLongClick()消息，导致该view相应长按事件。
		if( item.isOperateVirtualItem() == true )
		{
			textView.setLongClickable( false );
		}
		//xiatian add end
		//运营文件夹中要下载的图标，若此时数据库中保存的数据已经为下载完成，则要显示安装图标 wanghongjian add
		if( item.getIntent() != null )
		{
			textView.setOperateIconLoadDone( item.getIntent().getIntExtra( OperateDynamicMain.SHOW_OPERATE_ICON_DOWN_OR_INSTALL_KEY , Constants.DL_STATUS_NOTDOWN ) );
		}
		mContent.addViewToCellLayout( textView , insert ? 0 : -1 , (int)item.getId() , lp , true );
		if( item.isOperateIconItem() )//zhujieping add,原先在launcher中对文件夹进行判断操作，现放到文件夹中处理。因为一个普通文件夹中也可能包含虚链接、虚图标
		{
			if( OperateDynamicMain.getmOldOperateFolderVersion() == null )
			{
				String version = item.getIntent().getStringExtra( OperateDynamicMain.FOLDER_VERSION );
				OperateDynamicMain.setmOldOperateFolderVersion( version );
			}
			item.setShortcutType( LauncherSettings.Favorites.SHORTCUT_TYPE_OPERATE_DYNAMIC );
			OperateDynamicMain.updateOperateIcons( textView );
			OperateDynamicMain.addShortcutToAllOperateIcon( item );
		}
		return true;
	}
	
	public void onDragEnter(
			DragObject d )
	{
		mPreviousTargetCell[0] = -1;
		mPreviousTargetCell[1] = -1;
		mOnExitAlarm.cancelAlarm();
	}
	
	IOnAlarmListener mReorderAlarmListener = new IOnAlarmListener() {
		
		public void onAlarm(
				Alarm alarm )
		{
			realTimeReorder( mEmptyCell , mTargetCell );
		}
	};
	
	boolean readingOrderGreaterThan(
			int[] v1 ,
			int[] v2 )
	{
		if( v1[1] > v2[1] || ( v1[1] == v2[1] && v1[0] > v2[0] ) )
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	private void realTimeReorder(
			int[] empty ,
			int[] target )
	{
		boolean wrap;
		int startX;
		int endX;
		int startY;
		int delay = 0;
		float delayAmount = 30;
		if( readingOrderGreaterThan( target , empty ) )
		{
			wrap = empty[0] >= mContent.getCountX() - 1;
			startY = wrap ? empty[1] + 1 : empty[1];
			for( int y = startY ; y <= target[1] ; y++ )
			{
				startX = y == empty[1] ? empty[0] + 1 : 0;
				endX = y < target[1] ? mContent.getCountX() - 1 : target[0];
				for( int x = startX ; x <= endX ; x++ )
				{
					View v = mContent.getChildAt( x , y );
					if( mContent.animateChildToPosition( v , empty[0] , empty[1] , REORDER_ANIMATION_DURATION , delay , true , true ) )
					{
						empty[0] = x;
						empty[1] = y;
						delay += delayAmount;
						delayAmount *= 0.9;
					}
				}
			}
		}
		else
		{
			wrap = empty[0] == 0;
			startY = wrap ? empty[1] - 1 : empty[1];
			for( int y = startY ; y >= target[1] ; y-- )
			{
				startX = y == empty[1] ? empty[0] - 1 : mContent.getCountX() - 1;
				endX = y > target[1] ? 0 : target[0];
				for( int x = startX ; x >= endX ; x-- )
				{
					View v = mContent.getChildAt( x , y );
					if( mContent.animateChildToPosition( v , empty[0] , empty[1] , REORDER_ANIMATION_DURATION , delay , true , true ) )
					{
						empty[0] = x;
						empty[1] = y;
						delay += delayAmount;
						delayAmount *= 0.9;
					}
				}
			}
		}
	}
	
	public boolean isLayoutRtl()
	{
		//xiatian start	//整理判断“是否从左往右布局”的方法：由“mView.getLayoutDirection()”改为“getResources().getConfiguration().getLayoutDirection()”
		//		return Tools.isLayoutRTL( this );//xiatian del
		return LauncherAppState.isLayoutRTL();//xiatian add 
		//xiatian end
	}
	
	public void onDragOver(
			DragObject d )
	{
		final DragView dragView = d.dragView;
		final int scrollOffset = mScrollView.getScrollY();
		final float[] r = getDragViewVisualCenter( d.x , d.y , d.xOffset + mScrollView.getLeft() , d.yOffset + mScrollView.getTop() , dragView , null );//zhujieping modify,因mScrollView的位置为（0,0）没有问题，当有偏移后有错位
		r[0] -= getPaddingLeft();
		r[1] -= getPaddingTop();
		final long downTime = SystemClock.uptimeMillis();
		final MotionEvent translatedEv = MotionEvent.obtain( downTime , downTime , MotionEvent.ACTION_MOVE , d.x , d.y - mScrollView.getTop() , 0 );
		if( !mAutoScrollHelper.isEnabled() )
		{
			mAutoScrollHelper.setEnabled( true );
		}
		final boolean handled = mAutoScrollHelper.onTouch( mScrollView , translatedEv );
		translatedEv.recycle();
		if( handled )
		{
			mReorderAlarm.cancelAlarm();
		}
		else
		{
			mTargetCell = mContent.findNearestArea( (int)r[0] , (int)r[1] + scrollOffset , 1 , 1 , mTargetCell );
			if( isLayoutRtl() )
			{
				mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
			}
			if( mTargetCell[0] != mPreviousTargetCell[0] || mTargetCell[1] != mPreviousTargetCell[1] )
			{
				mReorderAlarm.cancelAlarm();
				mReorderAlarm.setIOnAlarmListener( mReorderAlarmListener );
				mReorderAlarm.setAlarm( REORDER_DELAY );
				mPreviousTargetCell[0] = mTargetCell[0];
				mPreviousTargetCell[1] = mTargetCell[1];
				mDragMode = DRAG_MODE_REORDER;
			}
			else
			{
				mDragMode = DRAG_MODE_NONE;
			}
		}
	}
	
	// This is used to compute the visual center of the dragView. The idea is that
	// the visual center represents the user's interpretation of where the item is, and hence
	// is the appropriate point to use when determining drop location.
	private float[] getDragViewVisualCenter(
			int x ,
			int y ,
			int xOffset ,
			int yOffset ,
			DragView dragView ,
			float[] recycle )
	{
		float res[];
		if( recycle == null )
		{
			res = new float[2];
		}
		else
		{
			res = recycle;
		}
		// These represent the visual top and left of drag view if a dragRect was provided.
		// If a dragRect was not provided, then they correspond to the actual view left and
		// top, as the dragRect is in that case taken to be the entire dragView.
		// R.dimen.dragViewOffsetY.
		int left = x - xOffset;
		int top = y - yOffset;
		// In order to find the visual center, we shift by half the dragRect
		res[0] = left + dragView.getDragRegion().width() / 2;
		res[1] = top + dragView.getDragRegion().height() / 2;
		return res;
	}
	
	IOnAlarmListener mOnExitAlarmListener = new IOnAlarmListener() {
		
		public void onAlarm(
				Alarm alarm )
		{
			completeDragExit();
		}
	};
	
	public void completeDragExit()
	{
		mLauncher.closeFolder();
		// zhujieping@2015/03/20 ADD START
		//打开文件夹时，移动icon出文件夹时，若文件夹关闭动画未结束，出现浮屏。文件夹关闭，mDragController中不应该再包含foler
		mDragController.removeDropTarget( (DropTarget)this );
		// zhujieping@2015/03/20 ADD END
		mCurrentDragInfo = null;
		mCurrentDragView = null;
		mSuppressOnAdd = false;
		mRearrangeOnClose = true;
	}
	
	public void onDragExit(
			DragObject d )
	{
		// Exiting folder; stop the auto scroller.
		mAutoScrollHelper.setEnabled( false );
		// We only close the folder if this is a true drag exit, ie. not because
		// a drop has occurred above the folder.
		if( !d.dragComplete )
		{
			mOnExitAlarm.setIOnAlarmListener( mOnExitAlarmListener );
			mOnExitAlarm.setAlarm( ON_EXIT_CLOSE_DELAY );
		}
		mReorderAlarm.cancelAlarm();
		mDragMode = DRAG_MODE_NONE;
	}
	
	public void onDropCompleted(
			final View target ,
			final DragObject d ,
			final boolean isFlingToDelete ,
			final boolean success )
	{
		if( mDeferDropAfterUninstall )
		{
			if( LauncherDefaultConfig.SWITCH_ENABLE_DEBUG )
				Log.d( TAG , "Deferred handling drop because waiting for uninstall." );
			mDeferredAction = new Runnable() {
				
				public void run()
				{
					onDropCompleted( target , d , isFlingToDelete , success );
					mDeferredAction = null;
				}
			};
			return;
		}
		boolean beingCalledAfterUninstall = mDeferredAction != null;
		boolean successfulDrop = success && ( !beingCalledAfterUninstall || mUninstallSuccessful );
		if( successfulDrop )
		{
			if( mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon )
			{
				replaceFolderWithFinalItem();
			}
		}
		else
		{
			setupContentForNumItems( getItemCount() );
			// The drag failed, we need to return the item to the folder
			//cheyingkun add start	//解决“长按文件夹中的一个图标时，并在电脑端卸载改应用后，文件夹被关闭并且图标没有被删除”的问题。【i_0010414】
			ShortcutInfo item;
			if( d.dragInfo instanceof AppInfo )
			{
				// Came from all apps -- make a copy
				item = ( (AppInfo)d.dragInfo ).makeShortcut();
			}
			else
			{
				item = (ShortcutInfo)d.dragInfo;
			}
			if( LauncherAppState.isApkInstalled( item.getIntent().getComponent() )//
					|| item.getItemType() == LauncherSettings.Favorites.ITEM_TYPE_VIRTUAL//cheyingkun add	//修改桌面默认配置
			)
			//cheyingkun add end
			{
				mFolderIcon.onDrop( d );
			}
			// zhujieping@2015/03/24 ADD START //长按文件夹中的最后一个图标时，并在电脑端卸载改应用后，删除文件夹
			else
			{
				//xiatian start	//需求:修改智能分类后文件夹解散的逻辑。（fix bug：解决“两个图标重叠生成文件夹，长按文件夹内一个应用图标时PC端将此应用卸载，卸载成功后手机端退出文件夹，文件夹不会解散”的问题。）
				//				if( getItemCount() == 0 )//xiatian del
				if( isNeedDeleteFolder( mInfo , mLauncher ) )//xiatian add
				//xiatian end
				{
					replaceFolderWithFinalItem();
				}
			}
			// zhujieping@2015/03/24 ADD END
		}
		if( target != this )
		{
			if( mOnExitAlarm.alarmPending() )
			{
				mOnExitAlarm.cancelAlarm();
				if( !successfulDrop )
				{
					mSuppressFolderDeletion = true;
				}
				completeDragExit();
			}
		}
		mDeleteFolderOnDropCompleted = false;
		mDragInProgress = false;
		mItemAddedBackToSelfViaIcon = false;
		mCurrentDragInfo = null;
		mCurrentDragView = null;
		mSuppressOnAdd = false;
		// Reordering may have occured, and we need to save the new item locations. We do this once
		// at the end to prevent unnecessary database operations.
		updateItemLocationsInDatabaseBatch();
	}
	
	public void deferCompleteDropAfterUninstallActivity()
	{
		mDeferDropAfterUninstall = true;
	}
	
	public void onUninstallActivityReturned(
			boolean success )
	{
		mDeferDropAfterUninstall = false;
		mUninstallSuccessful = success;
		if( mDeferredAction != null )
		{
			mDeferredAction.run();
		}
	}
	
	@Override
	public boolean supportsFlingToDelete()
	{
		return true;
	}
	
	public void onFlingToDelete(
			DragObject d ,
			int x ,
			int y ,
			PointF vec )
	{
		// Do nothing
	}
	
	@Override
	public void onFlingToDeleteCompleted()
	{
		// Do nothing
	}
	
	private void updateItemLocationsInDatabase()
	{
		ArrayList<View> list = getItemsInReadingOrder();
		for( int i = 0 ; i < list.size() ; i++ )
		{
			View v = list.get( i );
			ItemInfo info = (ItemInfo)v.getTag();
			LauncherModel.moveItemInDatabase( mLauncher , info , mInfo.getId() , 0 , info.getCellX() , info.getCellY() );
		}
	}
	
	private void updateItemLocationsInDatabaseBatch()
	{
		ArrayList<View> list = getItemsInReadingOrder();
		ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
		for( int i = 0 ; i < list.size() ; i++ )
		{
			View v = list.get( i );
			ItemInfo info = (ItemInfo)v.getTag();
			items.add( info );
		}
		LauncherModel.moveItemsInDatabase( mLauncher , items , mInfo.getId() , 0 );
	}
	
	public void addItemLocationsInDatabase()
	{
		ArrayList<View> list = getItemsInReadingOrder();
		for( int i = 0 ; i < list.size() ; i++ )
		{
			View v = list.get( i );
			ItemInfo info = (ItemInfo)v.getTag();
			LauncherModel.addItemToDatabase( mLauncher , info , mInfo.getId() , 0 , info.getCellX() , info.getCellY() , false );
		}
	}
	
	public void notifyDrop()
	{
		if( mDragInProgress )
		{
			mItemAddedBackToSelfViaIcon = true;
		}
	}
	
	public boolean isDropEnabled()
	{
		return true;
	}
	
	private void setupContentDimensions(
			int count )
	{
		ArrayList<View> list = getItemsInReadingOrder();
		int countX = mContent.getCountX();
		int countY = mContent.getCountY();
		boolean done = false;
		while( !done )
		{
			int oldCountX = countX;
			int oldCountY = countY;
			if( countX * countY < count )
			{
				// Current grid is too small, expand it
				if( ( countX <= countY || countY == mMaxCountY ) && countX < mMaxCountX )
				{
					countX++;
				}
				else if( countY < mMaxCountY )
				{
					countY++;
				}
				if( countY == 0 )
					countY++;
			}
			else if( ( countY - 1 ) * countX >= count && countY >= countX )
			{
				countY = Math.max( 0 , countY - 1 );
			}
			else if( ( countX - 1 ) * countY >= count )
			{
				countX = Math.max( 0 , countX - 1 );
			}
			done = countX == oldCountX && countY == oldCountY;
		}
		mContent.setGridSize( countX , countY );
		arrangeChildren( list );
	}
	
	public boolean isFull()
	{
		return getItemCount() >= mMaxNumItems;
	}
	
	protected void centerAboutIcon()
	{
		DragLayer.LayoutParams lp = (DragLayer.LayoutParams)getLayoutParams();
		DragLayer parent = (DragLayer)mLauncher.findViewById( R.id.drag_layer );
		int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
		int height = getFolderHeight();
		float scale = parent.getDescendantRectRelativeToSelf( mFolderIcon , mTempRect );
		LauncherAppState app = LauncherAppState.getInstance();
		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
		int centerX = (int)( mTempRect.left + mTempRect.width() * scale / 2 );
		int centerY = (int)( mTempRect.top + mTempRect.height() * scale / 2 );
		int centeredLeft = centerX - width / 2;
		int centeredTop = centerY - height / 2;
		int currentPage = mLauncher.getWorkspace().getNextPage();
		// In case the workspace is scrolling, we need to use the final scroll to compute
		// the folders bounds.
		mLauncher.getWorkspace().setFinalScrollForPageChange( currentPage );
		// We first fetch the currently visible CellLayoutChildren
		CellLayout currentLayout = (CellLayout)mLauncher.getWorkspace().getChildAt( currentPage );
		ShortcutAndWidgetContainer boundingLayout = currentLayout.getShortcutsAndWidgets();
		Rect bounds = new Rect();
		parent.getDescendantRectRelativeToSelf( boundingLayout , bounds );
		// We reset the workspaces scroll
		mLauncher.getWorkspace().resetFinalScrollForPageChange( currentPage );
		// We need to bound the folder to the currently visible CellLayoutChildren
		int left = Math.min( Math.max( bounds.left , centeredLeft ) , bounds.left + bounds.width() - width );
		int top = Math.min( Math.max( bounds.top , centeredTop ) , bounds.top + bounds.height() - height );
		if( grid.isPhone() && ( grid.getAvailableWidthPx() - width ) < grid.getIconWidthSizePx() )
		{
			// Center the folder if it is full (on phones only)
			left = ( grid.getAvailableWidthPx() - width ) / 2;
		}
		else if( width >= bounds.width() )
		{
			// If the folder doesn't fit within the bounds, center it about the desired bounds
			left = bounds.left + ( bounds.width() - width ) / 2;
		}
		if( height >= bounds.height() )
		{
			top = bounds.top + ( bounds.height() - height ) / 2;
		}
		// zhujieping@2015/04/14 ADD START,当workspace滑动时，得到的位置是滑动前的位置，导致得到的left大于屏宽，打开无法看到文件夹，【i_0010944】
		if( left > currentLayout.getWidth() )
		{
			left -= currentLayout.getWidth();
		}
		// zhujieping@2015/04/14 ADD END
		int folderPivotX = width / 2 + ( centeredLeft - left );
		int folderPivotY = height / 2 + ( centeredTop - top );
		setPivotX( folderPivotX );
		setPivotY( folderPivotY );
		mFolderIconPivotX = (int)( mFolderIcon.getMeasuredWidth() * ( 1.0f * folderPivotX / width ) );
		mFolderIconPivotY = (int)( mFolderIcon.getMeasuredHeight() * ( 1.0f * folderPivotY / height ) );
		lp.width = width;
		lp.height = height;
		lp.x = left;
		lp.y = top;
	}
	
	public float getPivotXForIconAnimation()
	{
		return mFolderIconPivotX;
	}
	
	public float getPivotYForIconAnimation()
	{
		return mFolderIconPivotY;
	}
	
	private void setupContentForNumItems(
			int count )
	{
		setupContentDimensions( count );
		DragLayer.LayoutParams lp = (DragLayer.LayoutParams)getLayoutParams();
		if( lp == null )
		{
			lp = new DragLayer.LayoutParams( 0 , 0 );
			lp.customPosition = true;
			setLayoutParams( lp );
		}
		centerAboutIcon();
	}
	
	private int getContentAreaHeight()
	{
		LauncherAppState app = LauncherAppState.getInstance();
		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
		Rect workspacePadding = grid.getWorkspacePadding( CellLayout.PORTRAIT );
		int maxContentAreaHeight = grid.getAvailableHeightPx() - 4 * grid.getEdgeMarginPx() - workspacePadding.top - workspacePadding.bottom - getPaddingTop() - getPaddingBottom() - mFolderNameHeight;
		return Math.min( maxContentAreaHeight , mContent.getDesiredHeight() );
	}
	
	private int getFolderHeight()
	{
		int height = getPaddingTop() + getPaddingBottom() + getContentAreaHeight() + mFolderNameHeight;
		return height;
	}
	
	protected void onMeasure(
			int widthMeasureSpec ,
			int heightMeasureSpec )
	{
		int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
		int height = getFolderHeight();
		int contentAreaWidthSpec = MeasureSpec.makeMeasureSpec( mContent.getDesiredWidth() , MeasureSpec.EXACTLY );
		int contentAreaHeightSpec = MeasureSpec.makeMeasureSpec( getContentAreaHeight() , MeasureSpec.EXACTLY );
		mContent.setFixedSize( mContent.getDesiredWidth() , mContent.getDesiredHeight() );
		mScrollView.measure( contentAreaWidthSpec , contentAreaHeightSpec );
		mFolderName.measure( contentAreaWidthSpec , MeasureSpec.makeMeasureSpec( mFolderNameHeight , MeasureSpec.EXACTLY ) );
		setMeasuredDimension( width , height );
	}
	
	private void arrangeChildren(
			ArrayList<View> list )
	{
		int[] vacant = new int[2];
		if( list == null )
		{
			list = getItemsInReadingOrder();
		}
		mContent.removeAllViews();
		for( int i = 0 ; i < list.size() ; i++ )
		{
			View v = list.get( i );
			mContent.getVacantCell( vacant , 1 , 1 );
			CellLayout.LayoutParams lp = (CellLayout.LayoutParams)v.getLayoutParams();
			lp.cellX = vacant[0];
			lp.cellY = vacant[1];
			EnhanceItemInfo info = (EnhanceItemInfo)v.getTag();
			if( info.getCellX() != vacant[0] || info.getCellY() != vacant[1] )
			{
				info.setCellX( vacant[0] );
				info.setCellY( vacant[1] );
				//解决“在显示智能分类更多应用图标的前提下，打开任一有更多应用图标的文件夹，在PC端卸载该文件夹中任意应用后，进入设置强制停止桌面后再启动桌面，这时之前的文件夹在关闭和打开的时候，都中多出一个更多应用图标”的问题。 , change by shlt@2015/03/03 UPD START
				//LauncherModel.addOrMoveItemInDatabase( mLauncher , info , mInfo.id , 0 , info.getCellX() , info.getCellY() );
				boolean mIsOperateVirtualItem = info.isOperateVirtualItem();
				if( mIsOperateVirtualItem )
				{
					boolean mIsOperateVirtualMoreAppItem = info.isOperateVirtualMoreAppItem();
					if( !mIsOperateVirtualMoreAppItem )
					{
						LauncherModel.addOrMoveItemInDatabase( mLauncher , info , mInfo.getId() , 0 , info.getCellX() , info.getCellY() );
					}
				}
				else
				{
					LauncherModel.addOrMoveItemInDatabase( mLauncher , info , mInfo.getId() , 0 , info.getCellX() , info.getCellY() );
				}
				//解决“在显示智能分类更多应用图标的前提下，打开任一有更多应用图标的文件夹，在PC端卸载该文件夹中任意应用后，进入设置强制停止桌面后再启动桌面，这时之前的文件夹在关闭和打开的时候，都中多出一个更多应用图标”的问题。 , change by shlt@2015/03/03 UPD END
			}
			boolean insert = false;
			mContent.addViewToCellLayout( v , insert ? 0 : -1 , (int)info.getId() , lp , true );
		}
		mItemsInvalidated = true;
	}
	
	public int getItemCount()
	{
		return mContent.getShortcutsAndWidgets().getChildCount();
	}
	
	public View getItemAt(
			int index )
	{
		return mContent.getShortcutsAndWidgets().getChildAt( index );
	}
	
	public void onCloseComplete()
	{
		DragLayer parent = (DragLayer)getParent();
		if( parent != null )
		{
			parent.removeView( this );
		}
		mDragController.removeDropTarget( (DropTarget)this );
		clearFocus();
		mFolderIcon.requestFocus();
		if( mRearrangeOnClose )
		{
			setupContentForNumItems( getItemCount() );
			mRearrangeOnClose = false;
		}
		//0010375: 【文件夹】智能分类成功后，展开只有一个图标的文件夹，退出文件夹后该文件夹直接消失只显示里面的应用图标 , change by shlt@2015/03/09 UPD START
		//if( getItemCount() <= 1 )
		//xiatian start	//需求:修改智能分类后文件夹解散的逻辑。
		//xiatian del start
		//		if( getItemCount() <= 0 //
		//				|| ( getItemCount() == 1 && mInfo.getCategoryFolderId() == Integer.MAX_VALUE ) )
		//xiatian del end
		if( isNeedDeleteFolder( mInfo , mLauncher ) )//xiatian add
		//xiatian end
		//0010375: 【文件夹】智能分类成功后，展开只有一个图标的文件夹，退出文件夹后该文件夹直接消失只显示里面的应用图标 , change by shlt@2015/03/09 UPD END
		{
			if( !mDragInProgress && !mSuppressFolderDeletion )
			{
				replaceFolderWithFinalItem();
			}
			else if( mDragInProgress )
			{
				mDeleteFolderOnDropCompleted = true;
			}
		}
		mSuppressFolderDeletion = false;
	}
	
	public void replaceFolderWithFinalItem()
	{
		// Add the last remaining child to the workspace in place of the folder
		if( isDestroyed() )
			return;
		Runnable onCompleteRunnable = new Runnable() {
			
			@Override
			public void run()
			{
				CellLayout cellLayout = mLauncher.getCellLayout( mInfo.getContainer() , mInfo.getScreenId() );
				View child = null;
				// Move the item from the folder to the workspace, in the position of the folder
				if( getItemCount() == 1 )
				{
					ShortcutInfo finalItem = mInfo.getContents().get( 0 );
					child = mLauncher.createShortcut( R.layout.application , cellLayout , finalItem );
					if( finalItem.isOperateIconItem() )
					{
						OperateDynamicMain.updateOperateIcons( child );
					}
					LauncherModel.addOrMoveItemInDatabase( mLauncher , finalItem , mInfo.getContainer() , mInfo.getScreenId() , mInfo.getCellX() , mInfo.getCellY() );
				}
				if( getItemCount() <= 1 )
				{
					// Remove the folder
					//					StackTraceElement[] stackTrace = new Throwable().getStackTrace();
					//					LauncherModel.updateItemArrays( mInfo , mInfo.id , stackTrace );
					LauncherModel.deleteItemFromDatabase( mLauncher , mInfo );
					cellLayout.removeView( mFolderIcon );
					if( mFolderIcon instanceof DropTarget )
					{
						mDragController.removeDropTarget( (DropTarget)mFolderIcon );
					}
					OperateDynamicMain.getmAllOperateFolderIcons().remove( mFolderIcon );
					mLauncher.removeFolder( mInfo );
				}
				// We add the child after removing the folder to prevent both from existing at
				// the same time in the CellLayout.  We need to add the new item with addInScreenFromBind()
				// to ensure that hotseat items are placed correctly.
				if( child != null )
				{
					mLauncher.getWorkspace().addInScreenFromBind( child , mInfo.getContainer() , mInfo.getScreenId() , mInfo.getCellX() , mInfo.getCellY() , mInfo.getSpanX() , mInfo.getSpanY() );
				}
				// zhujieping@2015/03/19 UPD START
				//i_0010509：进行智能分类，当文件夹内仅剩一个应用时，再将此应用拖至其他页面，此时当前空白页面不消失.
				mLauncher.getWorkspace().stripEmptyScreens();
				// zhujieping@2015/03/19 UPD END
				if( mInfo.getOperateIntent() != null )
				{
					String id = mInfo.getOperateIntent().getStringExtra( OperateDynamicMain.OPEARTE_DYNAMIC_ID );
					if( id != null )
						StatisticsHandle.DynamicEntryDelete( mInfo.getTitle() , Integer.parseInt( id ) );
				}
			}
		};
		View finalChild = getItemAt( 0 );
		if( finalChild != null )
		{
			mFolderIcon.performDestroyAnimation( finalChild , onCompleteRunnable );
		}
		//0010316: 【文件夹】桌面智能分类后将文件夹内图标移至桌面使文件夹变空，点击空白文件夹无法展开 , change by shlt@2015/03/06 ADD START
		else
		{
			onCompleteRunnable.run();
		}
		//0010316: 【文件夹】桌面智能分类后将文件夹内图标移至桌面使文件夹变空，点击空白文件夹无法展开 , change by shlt@2015/03/06 ADD END
		mDestroyed = true;
	}
	
	public boolean isDestroyed()
	{
		return mDestroyed;
	}
	
	// This method keeps track of the last item in the folder for the purposes
	// of keyboard focus
	private void updateTextViewFocus()
	{
		View lastChild = getItemAt( getItemCount() - 1 );
		getItemAt( getItemCount() - 1 );
		if( lastChild != null )
		{
			mFolderName.setNextFocusDownId( lastChild.getId() );
			mFolderName.setNextFocusRightId( lastChild.getId() );
			mFolderName.setNextFocusLeftId( lastChild.getId() );
			mFolderName.setNextFocusUpId( lastChild.getId() );
		}
	}
	
	public void onDrop(
			DragObject d )
	{
		ShortcutInfo item;
		if( d.dragInfo instanceof AppInfo )
		{
			// Came from all apps -- make a copy
			item = ( (AppInfo)d.dragInfo ).makeShortcut();
			item.setSpanX( 1 );
			item.setSpanY( 1 );
		}
		else
		{
			item = (ShortcutInfo)d.dragInfo;
		}
		// Dragged from self onto self, currently this is the only path possible, however
		// we keep this as a distinct code path.
		if( item == mCurrentDragInfo )
		{
			ShortcutInfo si = (ShortcutInfo)mCurrentDragView.getTag();
			CellLayout.LayoutParams lp = (CellLayout.LayoutParams)mCurrentDragView.getLayoutParams();
			lp.cellX = mEmptyCell[0];
			lp.cellY = mEmptyCell[1];
			// zhujieping@2015/06/02 UPD START,lp.cellX、Y是位置信息，设置给spanX、Y不合理，shortchutinfo的spanX、Y是1
			//拖动文件夹中的图标后松手，再拖动图标出文件夹，因spaxX值为0、或大于1，导致除0或数组越界异常以及图标放置在桌面边缘置显示一半【0011317】【0011329】
			//			si.setSpanX( lp.cellX );
			//			si.setSpanY( lp.cellY );
			si.setSpanX( 1 );
			si.setSpanY( 1 );
			// zhujieping@2015/06/02 UPD END
			mContent.addViewToCellLayout( mCurrentDragView , -1 , (int)item.getId() , lp , true );
			if( d.dragView.hasDrawn() )
			{
				mLauncher.getDragLayer().animateViewIntoPosition( d.dragView , mCurrentDragView );
			}
			else
			{
				d.deferDragViewCleanupPostAnimation = false;
				mCurrentDragView.setVisibility( VISIBLE );
			}
			mItemsInvalidated = true;
			setupContentDimensions( getItemCount() );
			mSuppressOnAdd = true;
		}
		mInfo.add( item );
	}
	
	// This is used so the item doesn't immediately appear in the folder when added. In one case
	// we need to create the illusion that the item isn't added back to the folder yet, to
	// to correspond to the animation of the icon back into the folder. This is
	public void hideItem(
			ShortcutInfo info )
	{
		View v = getViewForInfo( info );
		if( v != null )//zhujieping，遇到一次停止运行，后没复现，根据log加上保护
			v.setVisibility( INVISIBLE );
	}
	
	public void showItem(
			ShortcutInfo info )
	{
		View v = getViewForInfo( info );
		if( v != null )//zhujieping，添加非空保护
			v.setVisibility( VISIBLE );
	}
	
	public void onAdd(
			ShortcutInfo item )
	{
		onAddAndNotInsertDB( item );
		LauncherModel.addOrMoveItemInDatabase( mLauncher , item , mInfo.getId() , 0 , item.getCellX() , item.getCellY() );
	}
	
	//添加智能分类功能 , change by shlt@2015/02/11 ADD START
	private void onAddAndNotInsertDB(
			ShortcutInfo item )
	{
		mItemsInvalidated = true;
		// If the item was dropped onto this open folder, we have done the work associated
		// with adding the item to the folder, as indicated by mSuppressOnAdd being set
		if( mSuppressOnAdd )
			return;
		if( !findAndSetEmptyCells( item ) )
		{
			// The current layout is full, can we expand it?
			setupContentForNumItems( getItemCount() + 1 );
			findAndSetEmptyCells( item );
		}
		createAndAddShortcut( item , R.color.folder_items_text_color );
	}
	
	private void removeMoreAppView()
	{
		if( operateMoreAppShortcutInfo != null )
		{
			onRemove( operateMoreAppShortcutInfo );
		}
		operateMoreAppShortcutInfo = null;
	}
	
	//添加智能分类功能 , change by shlt@2015/02/11 ADD END
	public void onRemove(
			ShortcutInfo item )
	{
		mItemsInvalidated = true;
		// If this item is being dragged from this open folder, we have already handled
		// the work associated with removing the item, so we don't have to do anything here.
		if( item == mCurrentDragInfo )
			return;
		View v = getViewForInfo( item );
		mContent.removeView( v );
		if( mState == STATE_ANIMATING )
		{
			mRearrangeOnClose = true;
		}
		else
		{
			setupContentForNumItems( getItemCount() );
		}
		//0010316: 【文件夹】桌面智能分类后将文件夹内图标移至桌面使文件夹变空，点击空白文件夹无法展开 , change by shlt@2015/03/06 UPD START
		//if( getItemCount() <= 1 )
		//xiatian start	//需求:修改智能分类后文件夹解散的逻辑。
		//xiatian del start
		//			int childCount = getItemCount();
		//			if( childCount <= 0 // 
		//					|| ( childCount == 1 && ( (EnhanceItemInfo)( getItemAt( 0 ).getTag() ) ).isOperateVirtualMoreAppItem() ) //
		//			)
		//xiatian del end
		if( isNeedDeleteFolder( mInfo , mLauncher ) )//xiatian add
		//xiatian end
		//0010316: 【文件夹】桌面智能分类后将文件夹内图标移至桌面使文件夹变空，点击空白文件夹无法展开 , change by shlt@2015/03/06 UPD END
		{
			replaceFolderWithFinalItem();
		}
	}
	
	private View getViewForInfo(
			ShortcutInfo item )
	{
		for( int j = 0 ; j < mContent.getCountY() ; j++ )
		{
			for( int i = 0 ; i < mContent.getCountX() ; i++ )
			{
				View v = mContent.getChildAt( i , j );
				if( v != null && v.getTag() == item )
				{
					return v;
				}
			}
		}
		return null;
	}
	
	public void onItemsChanged()
	{
		updateTextViewFocus();
	}
	
	//添加智能分类功能 , change by shlt@2015/02/09 ADD START
	@Override
	public void itemIconChange(
			ShortcutInfo shortcutInfo )
	{
		if( mContent != null )
		{
			ShortcutAndWidgetContainer mShortcutsAndWidgets = mContent.getShortcutsAndWidgets();
			if( shortcutInfo != null && mShortcutsAndWidgets != null && mShortcutsAndWidgets.getChildCount() > 0 )
			{
				for( int i = 0 ; i < mShortcutsAndWidgets.getChildCount() ; i++ )
				{
					View child = mShortcutsAndWidgets.getChildAt( i );
					if( child instanceof BubbleTextView )
					{
						BubbleTextView item = (BubbleTextView)child;
						if( item.getText().equals( shortcutInfo.getTitle() ) )
						{
							item.setCompoundDrawables( null , Utilities.createIconDrawable( shortcutInfo.getIcon( mIconCache ) ) , null , null );
						}
					}
				}
			}
		}
	}
	//添加智能分类功能 , change by shlt@2015/02/09 ADD END
	;
	
	public void onTitleChanged(
			CharSequence title )
	{
		mFolderName.setText( title );
	}
	
	public ArrayList<View> getItemsInReadingOrder()
	{
		if( mItemsInvalidated )
		{
			mItemsInReadingOrder.clear();
			for( int j = 0 ; j < mContent.getCountY() ; j++ )
			{
				for( int i = 0 ; i < mContent.getCountX() ; i++ )
				{
					View v = mContent.getChildAt( i , j );
					if( v != null )
					{
						mItemsInReadingOrder.add( v );
					}
				}
			}
			mItemsInvalidated = false;
		}
		return mItemsInReadingOrder;
	}
	
	public void getLocationInDragLayer(
			int[] loc )
	{
		mLauncher.getDragLayer().getLocationInDragLayer( this , loc );
	}
	
	public void onFocusChange(
			View v ,
			boolean hasFocus )
	{
		isFolderNameFocusChange = true;//cheyingkun add	//解决“修改文件夹名称时，按方向键焦点框移动到图标上，软键盘没关闭”的问题【i_0014558】
		if( v == mFolderName && hasFocus )
		{
			startEditingFolderName();
		}
		//cheyingkun add start	//解决“修改文件夹名称时，按方向键焦点框移动到图标上，软键盘没关闭”的问题【i_0014558】
		else
		{
			if( mIsEditingName && !hasFocus )
			{
				dismissEditingName();
			}
		}
		isFolderNameFocusChange = false;
		//cheyingkun add end
	}
	
	@Override
	public void getHitRectRelativeToDragLayer(
			Rect outRect )
	{
		getHitRect( outRect );
	}
	
	//cheyingkun add start	//解决“文件夹内只有一个图标，托动此图标至卸载区域提示是否卸载时选择取消，返回桌面时应用图标消失”的问题。【i_0010416】
	public void setDestroyed(
			boolean mDestroyed )
	{
		this.mDestroyed = mDestroyed;
	}
	//cheyingkun add end
	;
	
	//xiatian add start	//需求：在文件夹打开状态下进入编辑模式，立刻关闭文件夹（不播放文件夹关闭的相关动画）。
	public void closeWithoutAnim()
	{
		if( !( getParent() instanceof DragLayer ) )
			return;
		setAlpha( 0 );
		setScaleX( 0.9f );
		setScaleY( 0.9f );
		onCloseComplete();
		setLayerType( LAYER_TYPE_NONE , null );
		setState( STATE_SMALL );
		//添加智能分类功能 , change by shlt@2015/02/11 ADD START
		removeMoreAppView();
		//添加智能分类功能 , change by shlt@2015/02/11 ADD END
	}
	//xiatian add end
	;
	
	//xiatian add start	//fix bug：解决“文件夹打开后，点击图标后，快速滑动至文件夹区域之外，这时图标在文件夹外部区域，相应长按事件”的问题。【i_0010683】
	public CellLayout getContent()
	{
		return mContent;
	}
	//xiatian add end
	;
	
	//xiatian add start	//需求:修改智能分类后文件夹解散的逻辑。
	//【备注】
	//	1、智能分类生成的文件夹，不主动解散
	//	2、非智能分类产生的文件夹
	//		2.1、当可以显示“更多应用”图标时，不主动解散
	//		2.2、当不可以显示“更多应用”图标时
	//			2.2.1、当文件夹内剩余图标个数大于1个时，不主动解散
	//			2.2.2、当文件夹内剩余图标个数小于等于1个时，主动解散
	public static boolean isNeedDeleteFolder(
			FolderInfo mInfo ,
			Context mContext )
	{
		if( mInfo == null || mContext == null )
		{
			return false;
		}
		boolean ret = false;
		if( mInfo.getCategoryFolderId() != Integer.MAX_VALUE )
		{//只要是智能分类生成的文件夹，不主动解散
			ret = false;
		}
		else
		{//非智能分类产生的文件夹，
			//xiatian start	//整理canShowMoreEntry方法。
			//			boolean showMore = CategoryHelper.getInstance( mContext ).canShowMoreEntry();//xiatian del
			boolean showMore = OperateHelp.getInstance( mContext ).canShowMoreEntry( mInfo.getCategoryFolderId() );//xiatian add
			//xiatian end
			if( showMore == true )
			{//当可以显示“更多应用”图标时，不主动解散
				ret = false;
			}
			else
			{
				if( mInfo.getContents().size() > 1 )
				{//当文件夹内剩余图标个数大于1个时，不主动解散
					ret = false;
				}
				else
				{
					ret = true;
				}
			}
		}
		return ret;
	}
	
	//xiatian add end
	/**
	 * 通过包名将对应的icon更换图标，运营文件夹使用 wanghongjian add
	 * @param pkgName
	 */
	public void refreshOperateFolderIconState(
			String pkgName ,
			String pkgId ,
			int state )
	{
		if( mContent != null && mContent.getShortcutsAndWidgets() != null )
		{
			for( int i = 0 ; i < mContent.getShortcutsAndWidgets().getChildCount() ; i++ )
			{
				View view = mContent.getShortcutsAndWidgets().getChildAt( i );
				if( view instanceof BubbleTextView )
				{
					BubbleTextView textView = (BubbleTextView)view;
					if( textView.getTag() instanceof ShortcutInfo && ( (ShortcutInfo)( textView.getTag() ) ).getIntent() != null )
					{
						String iconPkgName = ( (ShortcutInfo)( textView.getTag() ) ).getIntent().getStringExtra( pkgId );
						if( pkgName.equals( iconPkgName ) )
						{
							textView.setOperateIconLoadDone( state );
							textView.postInvalidate();
							return;
						}
					}
				}
			}
		}
	}
	
	// zhujieping@2015/06/17 ADD START
	public void getDescendantRectRelativeToSelf(
			Rect hitRect )
	{
		DragLayer draglayer = (DragLayer)mLauncher.findViewById( R.id.drag_layer );
		if( draglayer != null )
		{
			draglayer.getDescendantRectRelativeToSelf( this , hitRect );
		}
	}
	
	//cheyingkun add start	//文件夹推荐应用
	/**广告区域点击响应判断*/
	public void getDescendantRectRelativeToSelfMore(
			Rect hitRect )
	{
		getDescendantRectRelativeToSelf( hitRect );
	}
	
	//cheyingkun add end	//文件夹推荐应用
	public void setState(
			int mState )
	{
		this.mState = mState;
	}
	// zhujieping@2015/06/17 ADD END
	;
	
	private int getCellWidth()
	{
		int mCellWidth = 0;
		LauncherAppState app = LauncherAppState.getInstance();
		DynamicGrid mDynamicGrid = app.getDynamicGrid();
		if( mDynamicGrid != null )
		{
			DeviceProfile grid = mDynamicGrid.getDeviceProfile();
			if( grid != null )
			{
				//xiatian add start	//桌面图标显示的样式（详见BaseDefaultConfig.java中的“ITEM_STYLE_XXX”）。
				if( LauncherDefaultConfig.CONFIG_ITEM_STYLE == BaseDefaultConfig.ITEM_STYLE_NORMAL )
				{
					//xiatian start	//需求：文件夹打开后，每个格子的宽高和桌面每个格子的宽高，保持一致。
					//					mCellWidth = grid.getFolderCellWidthPx();//xiatian del
					mCellWidth = grid.getCellWidthPx();//xiatian add
					//xiatian end
				}
				else if( LauncherDefaultConfig.CONFIG_ITEM_STYLE == BaseDefaultConfig.ITEM_STYLE_ICON_EXTENDS_INTO_TITLE )
				{//文件夹打开后，每一个view的宽度。
					mCellWidth = grid.getSignleViewAvailableWidthPx();
				}
				//xiatian add end
			}
		}
		return mCellWidth;
	}
	
	private int getCellHeight()
	{
		int mCellHeight = 0;
		LauncherAppState app = LauncherAppState.getInstance();
		DynamicGrid mDynamicGrid = app.getDynamicGrid();
		if( mDynamicGrid != null )
		{
			DeviceProfile grid = mDynamicGrid.getDeviceProfile();
			if( grid != null )
			{
				//xiatian add start	//桌面图标显示的样式（详见BaseDefaultConfig.java中的“ITEM_STYLE_XXX”）。
				if( LauncherDefaultConfig.CONFIG_ITEM_STYLE == BaseDefaultConfig.ITEM_STYLE_NORMAL )
				{
					//xiatian start	//需求：文件夹打开后，每个格子的宽高和桌面每个格子的宽高，保持一致。
					//					mCellHeight = grid.getFolderCellHeightPx();//xiatian del
					mCellHeight = grid.getCellHeightPx();//xiatian add
					//xiatian end
				}
				else if( LauncherDefaultConfig.CONFIG_ITEM_STYLE == BaseDefaultConfig.ITEM_STYLE_ICON_EXTENDS_INTO_TITLE )
				{//文件夹打开后，每一个view的高度。
					mCellHeight = grid.getSignleViewAvailableHeightPx();
				}
				//xiatian add end
			}
		}
		return mCellHeight;
	}
	
	public void showDynamicDialog(
			final View dynamic )
	{
		if( dynamic != null )
		{
			post( new Runnable() {
				
				@Override
				public void run()
				{
					// TODO Auto-generated method stub
					if( dynamicView != null )
					{
						if( dynamicView.getVisibility() == View.VISIBLE )
						{
							return;
						}
						else
						{
							if( indexOfChild( dynamicView ) != -1 )
							{
								removeView( dynamicView );
								dynamicView = null;
							}
						}
					}
					dynamicView = dynamic;
					FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams( FrameLayout.LayoutParams.MATCH_PARENT , FrameLayout.LayoutParams.MATCH_PARENT , Gravity.BOTTOM );//dynamicView.getLayoutParams();
					addView( dynamicView , lp );
				}
			} );
		}
	}
	
	public boolean hideDynamicDialog()
	{
		if( dynamicView != null && indexOfChild( dynamicView ) != -1 )
		{
			boolean isVisible = dynamicView.getVisibility() == View.VISIBLE;
			removeView( dynamicView );
			dynamicView = null;
			if( isVisible )
			{
				return true;
			}
		}
		return false;
	}
	
	//cheyingkun add start	//文件夹推荐应用
	/**
	 * 显示推荐应用
	 */
	public void showNativeAdverDialog()
	{
		// 目前逻辑是,如果请求过数据,view就显示
		//即:请求成功情况下，第一天一个文件夹显示推荐应用；第二天最多有两个文件夹显示推荐应用。
		if( mNativeAdverViewLayout != null && indexOfChild( mNativeAdverViewLayout ) == -1//
				&& KmobAdverManager.getKmobAdverManager( mLauncher ).canShowOperateNativeDataWithOutTime()//cheyingkun add	//文件夹推荐应用读取服务器配置(开关、wifi更新、更新间隔)
		)
		{
			FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams( FrameLayout.LayoutParams.MATCH_PARENT , FrameLayout.LayoutParams.MATCH_PARENT , Gravity.BOTTOM );//dynamicView.getLayoutParams();
			lp.bottomMargin = LauncherAppState.getInstance().getVirtualKayHeightPx();//cheyingkun add	//飞利浦图标样式适配480*854带虚拟按键手机(调整布局、替换图标)。【c_0003557】
			addView( mNativeAdverViewLayout , lp );
		}
	}
	
	/**
	 * 隐藏推荐应用
	 */
	public void hideNativeAdverDialog()
	{
		if( mNativeAdverViewLayout != null && indexOfChild( mNativeAdverViewLayout ) != -1 )
		{
			removeView( mNativeAdverViewLayout );
		}
	}
	
	/**
	 * 获取推荐应用的图片信息
	 * @param createNativeDataByInfo
	 */
	public void getNativerAdverLogoBitmap(
			ArrayList<NativeData> createNativeDataByInfo )
	{
		//cheyingkun add start	//解决“文件夹推荐应用获取数据不够四个时，引起桌面重启”的问题。【c_0004308】
		if( createNativeDataByInfo == null || createNativeDataByInfo.size() != KmobAdverManager.folderNativeAdverAdverRequestNum )
		{//返回广告信息个数不对,直接结束.
			setGetDataForNativeAdver( false );
			if( LauncherDefaultConfig.SWITCH_ENABLE_DEBUG )
				Log.e( "operateNativeData" , "createNativeDataByInfo: " + createNativeDataByInfo.size() );
			return;
		}
		//cheyingkun add end
		if( this.createNativeDataByInfo == null || this.createNativeDataByInfo.size() == 0 )
		{
			this.createNativeDataByInfo = createNativeDataByInfo;
		}
		LauncherAppState app = LauncherAppState.getInstance();
		DynamicGrid mDynamicGrid = app.getDynamicGrid();
		DeviceProfile grid = mDynamicGrid.getDeviceProfile();
		for( NativeData nativeData : createNativeDataByInfo )
		{
			try
			{
				getImage( nativeData , grid.getIconWidthSizePx() , grid.getIconHeightSizePx() );
			}
			catch( NumberFormatException e )
			{
				e.printStackTrace();
			}
		}
	}
	
	/**
	 *  获取指定路径的图片
	 */
	private void getImage(
			final NativeData nativeData ,
			final int iconWidthSizePx ,
			final int iconHeightSizePx )
	{
		String urlpath = nativeData.getAdlogo();
		String title = nativeData.getHeadline();
		if( TextUtils.isEmpty( title ) )
		{
			title = "title is null" + nativeData;
		}
		final String tempTitle = title;
		@SuppressWarnings( "deprecation" )
		ImageRequest request = new ImageRequest( urlpath , new Response.Listener<Bitmap>() {
			
			@Override
			public void onResponse(
					final Bitmap response )
			{
				new Thread( new Runnable() {
					
					@Override
					public void run()
					{
						int width = response.getWidth();
						int height = response.getHeight();
						float scaleWidth = ( (float)iconWidthSizePx ) / width;
						float scaleHeight = ( (float)iconHeightSizePx ) / height;
						Matrix matrix = new Matrix();
						matrix.postScale( scaleWidth , scaleHeight );
						Bitmap resizedBitmap = Bitmap.createBitmap( response , 0 , 0 , width , height , matrix , true );
						Message msg = new Message();
						nativeData.setAdlogoBitmap( resizedBitmap );
						msg.what = GET_NATIVE_ADVER_LOGO_BITMAP_SUCCESS;
						msg.obj = tempTitle;
						if( LauncherDefaultConfig.SWITCH_ENABLE_DEBUG )
							Log.i( "operateNativeData" , StringUtils.concat( "FolderOperateNativeAdver onResponse GET_NATIVE_ADVER_LOGO_BITMAP_SUCCESS title:" , tempTitle ) );
						mHandler.sendMessage( msg );
					}
				} ).start();
			}
		} , 0 , 0 , Bitmap.Config.RGB_565 , new Response.ErrorListener() {
			
			public void onErrorResponse(
					VolleyError arg0 )
			{
				if( LauncherDefaultConfig.SWITCH_ENABLE_DEBUG )
					Log.w( "operateNativeData" , StringUtils.concat( "FolderOperateNativeAdver onErrorResponse GET_NATIVE_ADVER_LOGO_BITMAP_FAIL title:" , tempTitle , " arg0: " + arg0 ) );
				Message msg = new Message();
				msg.what = GET_NATIVE_ADVER_LOGO_BITMAP_FAIL;
				msg.obj = tempTitle;
				mHandler.sendMessage( msg );
			};
		} );
		queue.add( request );
	}
	
	/**
	 * 清除推荐应用列表信息
	 */
	private void clearNativeData()
	{
		if( createNativeDataByInfo != null )//cheyingkun add	//文件夹推荐应用获取广告失败时，桌面重启。【i_0013200】
		{
			createNativeDataByInfo.clear();
		}
		getNativeAdverLogoBitmapSuccessTitle.clear();
		getNativeAdverLogoBitmapFailTitle.clear();
	}
	
	//cheyingkun add end	//文件夹推荐应用
	//zhujieping add start
	@Override
	public void onThemeChanged(
			Object arg0 ,
			Object arg1 )
	{
		// TODO Auto-generated method stub
		mContent.setCellDimensions( getCellWidth() , getCellHeight() );//换主题时重新设置格子的大小，否则当某个图标较小的主题切换到图标较大的主题，文件夹中图标显示不全。
		mContent.onThemeChanged( arg0 , arg1 );
	}
	//zhujieping add end
}
